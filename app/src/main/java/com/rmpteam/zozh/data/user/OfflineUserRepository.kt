package com.rmpteam.zozh.data.user

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.map
import java.util.UUID

class OfflineUserRepository(
    private val fakeUserProfileDatasource: FakeUserProfileDatasource,
    private val userPreferencesRepository: UserPreferencesRepository
) : UserRepository {

    // getCurrentUser now directly maps from UserPreferencesRepository
    override fun getCurrentUser(): Flow<UserProfile?> = userPreferencesRepository.currentUserProfile

    override suspend fun setCurrentUser(userProfile: UserProfile?) {
        userPreferencesRepository.saveCurrentUserProfile(userProfile)
    }
    
    // This method might be used by parts of the app that expect to fetch any user, not just current.
    // It now queries the fake data source.
    override fun getUserById(id: String): Flow<UserProfile?> {
        // Fake datasource is not reactive, so we wrap the immediate result in a flow
        // This is a simplification; for a truly reactive fake, it would need its own Flow
        return kotlinx.coroutines.flow.flowOf(fakeUserProfileDatasource.findUserById(id))
    }

    // This method might be used by admin panels or debug screens.
    // It now queries the fake data source.
    override fun getAllUsers(): Flow<List<UserProfile>> {
        // Similar to getUserById, wrap the list in a flow.
        // return kotlinx.coroutines.flow.flowOf(fakeUserProfileDatasource.getAllUsers()) 
        // Assuming FakeUserProfileDatasource does not have getAllUsers, returning empty or could be implemented
        return kotlinx.coroutines.flow.flowOf(emptyList()) // Placeholder if FakeUserProfileDatasource doesn't expose all users
    }

    // This is more for creating users internally, not necessarily part of public API for registration
    override suspend fun insertUser(userProfile: UserProfile): String {
        val result = fakeUserProfileDatasource.addUser(userProfile)
        return result.fold(
            onSuccess = { it.id },
            onFailure = { throw it } // Or handle error differently
        )
    }

    override suspend fun updateUser(userProfile: UserProfile) {
        val result = fakeUserProfileDatasource.updateUser(userProfile)
        result.onSuccess { updatedUser ->
            // If the updated user is the current user, also update DataStore
            val currentUser = getCurrentUser().firstOrNull()
            if (currentUser?.id == updatedUser.id) {
                setCurrentUser(updatedUser)
            }
        }.onFailure { 
            throw it // Or handle error
        }
    }

    // deleteUser might not be needed if users are only in fake source and cleared on restart
    // If kept, it should remove from FakeUserProfileDatasource and clear from DataStore if it's current user
    override suspend fun deleteUser(userProfile: UserProfile) {
        // fakeUserProfileDatasource.removeUser(userProfile.id) // Assuming such a method exists
        val currentUser = getCurrentUser().firstOrNull()
        if (currentUser?.id == userProfile.id) {
            logout()
        }
    }

    override suspend fun login(username: String, password: String): Result<UserProfile> {
        val user = fakeUserProfileDatasource.findUserByUsername(username)
        return if (user != null && user.password == password) { // Password check should be more secure in a real app
            setCurrentUser(user)
            Result.success(user)
        } else {
            Result.failure(Exception("Invalid username or password"))
        }
    }

    // Changed signature to take a UserProfile object, assuming password is set.
    // ID will be generated by FakeUserProfileDatasource.
    override suspend fun register(userToRegister: UserProfile): Result<UserProfile> {
         val result = fakeUserProfileDatasource.addUser(userToRegister)
         return result.fold(
             onSuccess = { newUser ->
                 setCurrentUser(newUser) // Log in the user immediately after registration
                 Result.success(newUser)
             },
             onFailure = {
                 Result.failure(it)
             }
         )
    }
    
    // Simplified register to match original interface, though less data can be passed.
    // Consider changing UserRepository interface for register to take more UserProfile details.
    // For now, implementing the existing interface:
    // override suspend fun register(username: String, password: String): Result<UserProfile> {
    //     val existingUser = fakeUserProfileDatasource.findUserByUsername(username)
    //     if (existingUser != null) {
    //         return Result.failure(Exception("Username already exists"))
    //     }
    //     val newUser = UserProfile(
    //         id = UUID.randomUUID().toString(), // ID is generated here, FakeUserProfileDatasource also generates one. Choose one source of truth.
    //         username = username,
    //         password = password // Store password directly - very insecure for real app
    //     )
    //     return register(newUser) // Call the more detailed register method
    // }


    override suspend fun logout() {
        userPreferencesRepository.clearCurrentUserProfile()
    }
} 